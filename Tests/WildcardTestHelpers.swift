@testable import TestingWildcards

// could I make my own protocol based on CaseIterable but which adds iterable over
// associated types that are CaseIterable?
public enum Mode: CaseIterable, InvariantValues, CustomStringConvertible {
//    case alpha, beta, gamma(Bool)
    case alpha, beta, gamma

    public var description: String {
        switch self {
        case .alpha: return "Alpha"
        case .beta: return "Beta"
        case .gamma: return "Gamma"
        }
    }
}

public struct Example: WildcardPrototyping, CustomStringConvertible {
    public static var prototype: Self {
        .init()
    }

//    public init() { }

    // recommended pattern -- set all properties values to default, then prototype can just call the autogenerated .init()
    public var name: String = "bob"
    public var flag: Bool = false
    public var mode: Mode = .alpha
    public var count: Int = 0
    public var a: Int = 0
    public var b: Int = 0
    public var c: Int = 0
    public var error: SomeError? = nil


    public var description: String {
        "[Example name: \(name) flag: \(flag), mode: \(mode), count: \(count), abc: \(a) \(b) \(c) error: \(String(describing: error))])"
    }

//    public static func callAsFunction(_ wildcardPaths: [WildcardPath<Self>]) -> [Self] {
//        TestingWildcards.allInvariantCombinations(Self.prototype, wildcardPaths: wildcardPaths)
//    }

}

public enum SomeError: Error, InvariantValues, CaseIterable {
    case catWokeUp
    case dogGotRainedOn
}
